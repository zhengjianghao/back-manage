{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\nvar React = require('react');\nvar React__default = _interopDefault(React);\nvar shallowEqual = _interopDefault(require('shallowequal'));\nvar levenshtein = _interopDefault(require('fast-levenshtein'));\nvar ReactDOM = _interopDefault(require('react-dom'));\nvar PropTypes = _interopDefault(require('prop-types'));\nvar defaultPolyfill = require('react-lifecycles-compat');\nvar defaultPolyfill__default = _interopDefault(defaultPolyfill);\nvar hoistNonReactStatic = _interopDefault(require('hoist-non-react-statics'));\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n/* eslint-disable no-underscore-dangle */\n\nvar isCompositeComponent = function isCompositeComponent(type) {\n  return typeof type === 'function';\n};\nvar isReloadableComponent = function isReloadableComponent(type) {\n  return typeof type === 'function' || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object';\n};\nvar getComponentDisplayName = function getComponentDisplayName(type) {\n  var displayName = type.displayName || type.name;\n  return displayName && displayName !== 'ReactComponent' ? displayName : 'Component';\n};\nvar reactLifeCycleMountMethods = ['componentWillMount', 'componentDidMount'];\nfunction isReactClass(Component) {\n  return !!(Component.prototype && (React__default.Component.prototype.isPrototypeOf(Component.prototype) ||\n  // react 14 support\n  Component.prototype.isReactComponent || Component.prototype.componentWillMount || Component.prototype.componentWillUnmount || Component.prototype.componentDidMount || Component.prototype.componentDidUnmount || Component.prototype.render));\n}\nfunction isReactClassInstance(Component) {\n  return Component && isReactClass({\n    prototype: Object.getPrototypeOf(Component)\n  });\n}\nvar getInternalInstance = function getInternalInstance(instance) {\n  return instance._reactInternalFiber ||\n  // React 16\n  instance._reactInternalInstance ||\n  // React 15\n  null;\n};\nvar updateInstance = function updateInstance(instance) {\n  var updater = instance.updater,\n    forceUpdate = instance.forceUpdate;\n  if (typeof forceUpdate === 'function') {\n    instance.forceUpdate();\n  } else if (updater && typeof updater.enqueueForceUpdate === 'function') {\n    updater.enqueueForceUpdate(instance);\n  }\n};\nvar isFragmentNode = function isFragmentNode(_ref) {\n  var type = _ref.type;\n  return React__default.Fragment && type === React__default.Fragment;\n};\nvar ContextType = React__default.createContext ? React__default.createContext() : null;\nvar ConsumerType = ContextType && ContextType.Consumer.$$typeof;\nvar ProviderType = ContextType && ContextType.Provider.$$typeof;\nvar MemoType = React__default.memo && React__default.memo(function () {\n  return null;\n}).$$typeof;\nvar LazyType = React__default.lazy && React__default.lazy(function () {\n  return null;\n}).$$typeof;\nvar ForwardType = React__default.forwardRef && React__default.forwardRef(function () {\n  return null;\n}).$$typeof;\nvar CONTEXT_CURRENT_VALUE = '_currentValue';\nvar isContextConsumer = function isContextConsumer(_ref2) {\n  var type = _ref2.type;\n  return type && (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && '$$typeof' in type && type.$$typeof === ConsumerType && ConsumerType;\n};\nvar isContextProvider = function isContextProvider(_ref3) {\n  var type = _ref3.type;\n  return type && (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && '$$typeof' in type && type.$$typeof === ProviderType && ProviderType;\n};\nvar isMemoType = function isMemoType(_ref4) {\n  var type = _ref4.type;\n  return type && (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && '$$typeof' in type && type.$$typeof === MemoType && MemoType;\n};\nvar isLazyType = function isLazyType(_ref5) {\n  var type = _ref5.type;\n  return type && (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && '$$typeof' in type && type.$$typeof === LazyType && LazyType;\n};\nvar isForwardType = function isForwardType(_ref6) {\n  var type = _ref6.type;\n  return type && (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && '$$typeof' in type && type.$$typeof === ForwardType && ForwardType;\n};\nvar isContextType = function isContextType(type) {\n  return isContextConsumer(type) || isContextProvider(type);\n};\nvar getElementType = function getElementType(type) {\n  var element = {\n    type: type\n  };\n  if (isContextConsumer(element)) {\n    return 'Consumer';\n  }\n  if (isContextProvider(element)) {\n    return 'Provider';\n  }\n  if (isLazyType(element)) {\n    return 'Lazy';\n  }\n  if (isMemoType(element)) {\n    return 'Memo';\n  }\n  if (isForwardType(element)) {\n    return 'Forward';\n  }\n  if (isReactClass(type)) {\n    return 'Class';\n  }\n  if (typeof element === 'function') {\n    return 'FC';\n  }\n  return 'unknown';\n};\nvar getContextProvider = function getContextProvider(type) {\n  return type && type._context;\n};\nvar configuration = {\n  // Log level\n  logLevel: 'error',\n  // Allows using SFC without changes\n  pureSFC: true,\n  // keep render method unpatched, moving sideEffect to componentDidUpdate\n  pureRender: true,\n  // Allows SFC to be used, enables \"intermediate\" components used by Relay, should be disabled for Preact\n  allowSFC: true,\n  // Allow reload of effect hooks with non zero dependency list\n  reloadHooks: true,\n  // Allow reload of mount effect hooks - zero deps\n  reloadLifeCycleHooks: false,\n  // Enables hook reload on hook body change\n  reloadHooksOnBodyChange: true,\n  // Disable \"hot-replacement-render\"\n  disableHotRenderer: false,\n  // @private\n  integratedComparator: false,\n  // @private\n  integratedResolver: false,\n  // Disable \"hot-replacement-render\" when injection into react-dom is made\n  disableHotRendererWhenInjected: true,\n  // Controls `react-🔥-dom patch` notification\n  showReactDomPatchNotification: true,\n  // Hook on babel component register.\n  onComponentRegister: false,\n  // Hook on React renders for a first time component\n  onComponentCreate: false,\n  // flag to completely disable RHL for SFC. Probably don't use it without dom patch made.\n  ignoreSFC: false,\n  // ignoreSFC when injection into react-dom is made\n  ignoreSFCWhenInjected: true,\n  // flag to completely disable RHL for Components\n  ignoreComponents: false,\n  // default value for AppContainer errorOverlay\n  errorReporter: undefined,\n  // Global error overlay\n  ErrorOverlay: undefined,\n  // Actively track lazy loaded components\n  trackTailUpdates: true,\n  // wrap lazy with AppProvider to allow independent updates\n  wrapLazy: true,\n  // react hot dom features enabled\n  IS_REACT_MERGE_ENABLED: false\n};\nvar internalConfiguration = {\n  // control proxy creation\n  disableProxyCreation: false\n};\nvar setConfiguration = function setConfiguration(config) {\n  // not using Object.assing for IE11 compliance\n  for (var i in config) {\n    if (config.hasOwnProperty(i)) {\n      configuration[i] = config[i];\n    }\n  }\n};\n\n/* eslint-disable no-console */\n\nvar logger = {\n  debug: function debug() {\n    if (['debug'].indexOf(configuration.logLevel) !== -1) {\n      var _console;\n      (_console = console).debug.apply(_console, arguments);\n    }\n  },\n  log: function log() {\n    if (['debug', 'log'].indexOf(configuration.logLevel) !== -1) {\n      var _console2;\n      (_console2 = console).log.apply(_console2, arguments);\n    }\n  },\n  warn: function warn() {\n    if (['debug', 'log', 'warn'].indexOf(configuration.logLevel) !== -1) {\n      var _console3;\n      (_console3 = console).warn.apply(_console3, arguments);\n    }\n  },\n  error: function error() {\n    if (['debug', 'log', 'warn', 'error'].indexOf(configuration.logLevel) !== -1) {\n      var _console4;\n      (_console4 = console).error.apply(_console4, arguments);\n    }\n  }\n};\n\n/* eslint-disable no-eval, func-names */\n\nfunction safeReactConstructor(Component, lastInstance) {\n  try {\n    if (lastInstance) {\n      return new Component(lastInstance.props, lastInstance.context);\n    }\n    return new Component({}, {});\n  } catch (e) {\n    // some components, like Redux connect could not be created without proper context\n  }\n  return null;\n}\nfunction isNativeFunction(fn) {\n  return typeof fn === 'function' ? fn.toString().indexOf('[native code]') > 0 : false;\n}\nvar identity = function identity(a) {\n  return a;\n};\nvar indirectEval = eval;\nvar doesSupportClasses = function () {\n  try {\n    indirectEval('class Test {}');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}();\nvar ES6ProxyComponentFactory = function ES6ProxyComponentFactory(InitialParent, postConstructionAction) {\n  return indirectEval('\\n(function(InitialParent, postConstructionAction) {\\n  return class ' + (InitialParent.name || 'HotComponent') + ' extends InitialParent {\\n    /*\\n     ! THIS IS NOT YOUR COMPONENT !\\n     !  THIS IS REACT-HOT-LOADER  !\\n  \\n     this is a \"' + InitialParent.name + '\" component, patched by React-Hot-Loader\\n     Sorry, but the real class code was hidden behind this facade\\n     Please refer to https://github.com/gaearon/react-hot-loader for details...\\n    */    \\n    \\n    constructor(props, context) {\\n      super(props, context)\\n      postConstructionAction.call(this)\\n    }\\n  }\\n})\\n')(InitialParent, postConstructionAction);\n};\nvar ES5ProxyComponentFactory = function ES5ProxyComponentFactory(InitialParent, postConstructionAction) {\n  function ProxyComponent(props, context) {\n    InitialParent.call(this, props, context);\n    postConstructionAction.call(this);\n  }\n  ProxyComponent.prototype = Object.create(InitialParent.prototype);\n  Object.setPrototypeOf(ProxyComponent, InitialParent);\n  return ProxyComponent;\n};\nvar proxyClassCreator = doesSupportClasses ? ES6ProxyComponentFactory : ES5ProxyComponentFactory;\nfunction getOwnKeys(target) {\n  return [].concat(Object.getOwnPropertyNames(target), Object.getOwnPropertySymbols(target));\n}\nfunction shallowStringsEqual(a, b) {\n  for (var key in a) {\n    if (String(a[key]) !== String(b[key])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction deepPrototypeUpdate(dest, source) {\n  var deepDest = Object.getPrototypeOf(dest);\n  var deepSrc = Object.getPrototypeOf(source);\n  if (deepDest && deepSrc && deepSrc !== deepDest) {\n    deepPrototypeUpdate(deepDest, deepSrc);\n  }\n  if (source.prototype && source.prototype !== dest.prototype) {\n    dest.prototype = source.prototype;\n  }\n}\nfunction safeDefineProperty(target, key, props) {\n  try {\n    Object.defineProperty(target, key, props);\n  } catch (e) {\n    logger.warn('Error while wrapping', key, ' -> ', e);\n  }\n}\nvar PREFIX = '__reactstandin__';\nvar PROXY_KEY = PREFIX + 'key';\nvar GENERATION = PREFIX + 'proxyGeneration';\nvar REGENERATE_METHOD = PREFIX + 'regenerateByEval';\nvar UNWRAP_PROXY = PREFIX + 'getCurrent';\nvar CACHED_RESULT = PREFIX + 'cachedResult';\nvar PROXY_IS_MOUNTED = PREFIX + 'isMounted';\nvar RENDERED_GENERATION = 'REACT_HOT_LOADER_RENDERED_GENERATION';\nvar RESERVED_STATICS = ['length', 'displayName', 'name', 'arguments', 'caller', 'prototype', 'toString', 'valueOf', 'isStatelessFunctionalProxy', PROXY_KEY, UNWRAP_PROXY];\nfunction transferStaticProps(ProxyComponent, savedDescriptors, PreviousComponent, NextComponent) {\n  Object.getOwnPropertyNames(ProxyComponent).forEach(function (key) {\n    if (RESERVED_STATICS.indexOf(key) !== -1) {\n      return;\n    }\n    var prevDescriptor = Object.getOwnPropertyDescriptor(ProxyComponent, key);\n    var savedDescriptor = savedDescriptors[key];\n    if (!shallowEqual(prevDescriptor, savedDescriptor)) {\n      safeDefineProperty(NextComponent, key, prevDescriptor);\n    }\n  });\n\n  // Copy newly defined static methods and properties\n  Object.getOwnPropertyNames(NextComponent).forEach(function (key) {\n    if (RESERVED_STATICS.indexOf(key) !== -1) {\n      return;\n    }\n    var prevDescriptor = PreviousComponent && Object.getOwnPropertyDescriptor(ProxyComponent, key);\n    var savedDescriptor = savedDescriptors[key];\n\n    // Skip redefined descriptors\n    if (prevDescriptor && savedDescriptor && !shallowEqual(savedDescriptor, prevDescriptor)) {\n      safeDefineProperty(NextComponent, key, prevDescriptor);\n      return;\n    }\n    if (prevDescriptor && !savedDescriptor) {\n      safeDefineProperty(ProxyComponent, key, prevDescriptor);\n      return;\n    }\n    var nextDescriptor = _extends({}, Object.getOwnPropertyDescriptor(NextComponent, key), {\n      configurable: true\n    });\n    savedDescriptors[key] = nextDescriptor;\n    safeDefineProperty(ProxyComponent, key, nextDescriptor);\n  });\n\n  // Remove static methods and properties that are no longer defined\n  Object.getOwnPropertyNames(ProxyComponent).forEach(function (key) {\n    if (RESERVED_STATICS.indexOf(key) !== -1) {\n      return;\n    }\n    // Skip statics that exist on the next class\n    if (NextComponent.hasOwnProperty(key)) {\n      return;\n    }\n    // Skip non-configurable statics\n    var proxyDescriptor = Object.getOwnPropertyDescriptor(ProxyComponent, key);\n    if (proxyDescriptor && !proxyDescriptor.configurable) {\n      return;\n    }\n    var prevDescriptor = PreviousComponent && Object.getOwnPropertyDescriptor(PreviousComponent, key);\n    var savedDescriptor = savedDescriptors[key];\n\n    // Skip redefined descriptors\n    if (prevDescriptor && savedDescriptor && !shallowEqual(savedDescriptor, prevDescriptor)) {\n      return;\n    }\n    safeDefineProperty(ProxyComponent, key, {\n      value: undefined\n    });\n  });\n  return savedDescriptors;\n}\nfunction mergeComponents(ProxyComponent, NextComponent, InitialComponent, lastInstance, injectedMembers) {\n  var injectedCode = {};\n  try {\n    var nextInstance = safeReactConstructor(NextComponent, lastInstance);\n    try {\n      // Bypass babel class inheritance checking\n      deepPrototypeUpdate(InitialComponent, NextComponent);\n    } catch (e) {\n      // It was ES6 class\n    }\n    var proxyInstance = safeReactConstructor(ProxyComponent, lastInstance);\n    if (!nextInstance || !proxyInstance) {\n      return injectedCode;\n    }\n    var mergedAttrs = _extends({}, proxyInstance, nextInstance);\n    var hasRegenerate = proxyInstance[REGENERATE_METHOD];\n    var ownKeys = getOwnKeys(Object.getPrototypeOf(ProxyComponent.prototype));\n    Object.keys(mergedAttrs).forEach(function (key) {\n      if (key.indexOf(PREFIX) === 0) return;\n      var nextAttr = nextInstance[key];\n      var prevAttr = proxyInstance[key];\n      if (nextAttr) {\n        if (isNativeFunction(nextAttr) || isNativeFunction(prevAttr)) {\n          // this is bound method\n          var isSameArity = nextAttr.length === prevAttr.length;\n          var existsInPrototype = ownKeys.indexOf(key) >= 0 || ProxyComponent.prototype[key];\n          if ((isSameArity || !prevAttr) && existsInPrototype) {\n            if (hasRegenerate) {\n              injectedCode[key] = 'Object.getPrototypeOf(this)[\\'' + key + '\\'].bind(this)';\n            } else {\n              logger.warn('React Hot Loader:,', 'Non-controlled class', ProxyComponent.name, 'contains a new native or bound function ', key, nextAttr, '. Unable to reproduce');\n            }\n          } else {\n            logger.warn('React Hot Loader:', 'Updated class ', ProxyComponent.name, 'contains native or bound function ', key, nextAttr, '. Unable to reproduce, use arrow functions instead.', '(arity: ' + nextAttr.length + '/' + prevAttr.length + ', proto: ' + (existsInPrototype ? 'yes' : 'no'));\n          }\n          return;\n        }\n        var nextString = String(nextAttr);\n        var injectedBefore = injectedMembers[key];\n        var isArrow = nextString.indexOf('=>') >= 0;\n        var isFunction = nextString.indexOf('function') >= 0 || isArrow;\n        var referToThis = nextString.indexOf('this') >= 0;\n        if (nextString !== String(prevAttr) || injectedBefore && nextString !== String(injectedBefore) || isArrow && referToThis) {\n          if (!hasRegenerate) {\n            if (!isFunction) {\n              // just copy prop over\n              injectedCode[key] = nextAttr;\n            } else {\n              logger.warn('React Hot Loader:', ' Updated class ', ProxyComponent.name, 'had different code for', key, nextAttr, '. Unable to reproduce. Regeneration support needed.');\n            }\n          } else {\n            injectedCode[key] = nextAttr;\n          }\n        }\n      }\n    });\n  } catch (e) {\n    logger.warn('React Hot Loader:', e);\n  }\n  return injectedCode;\n}\nfunction checkLifeCycleMethods(ProxyComponent, NextComponent) {\n  try {\n    var p1 = Object.getPrototypeOf(ProxyComponent.prototype);\n    var p2 = NextComponent.prototype;\n    reactLifeCycleMountMethods.forEach(function (key) {\n      var d1 = Object.getOwnPropertyDescriptor(p1, key) || {\n        value: p1[key]\n      };\n      var d2 = Object.getOwnPropertyDescriptor(p2, key) || {\n        value: p2[key]\n      };\n      if (!shallowStringsEqual(d1, d2)) {\n        logger.warn('React Hot Loader:', 'You did update', ProxyComponent.name, 's lifecycle method', key, '. Unable to repeat');\n      }\n    });\n  } catch (e) {\n    // Ignore errors\n  }\n}\nfunction inject(target, currentGeneration, injectedMembers) {\n  if (target[GENERATION] !== currentGeneration) {\n    var hasRegenerate = !!target[REGENERATE_METHOD];\n    Object.keys(injectedMembers).forEach(function (key) {\n      try {\n        if (hasRegenerate) {\n          var usedThis = String(injectedMembers[key]).match(/_this([\\d]+)/gi) || [];\n          target[REGENERATE_METHOD](key, '(function REACT_HOT_LOADER_SANDBOX () {\\n          var _this  = this; // common babel transpile\\n          ' + usedThis.map(function (name) {\n            return 'var ' + name + ' = this;';\n          }) + '\\n\\n          return ' + injectedMembers[key] + ';\\n          }).call(this)');\n        } else {\n          target[key] = injectedMembers[key];\n        }\n      } catch (e) {\n        logger.warn('React Hot Loader: Failed to regenerate method ', key, ' of class ', target);\n        logger.warn('got error', e);\n      }\n    });\n    target[GENERATION] = currentGeneration;\n  }\n}\nvar has = Object.prototype.hasOwnProperty;\nvar proxies = new WeakMap();\nvar resetClassProxies = function resetClassProxies() {\n  proxies = new WeakMap();\n};\nvar blackListedClassMembers = ['constructor', 'render', 'componentWillMount', 'componentDidMount', 'componentDidCatch', 'componentWillReceiveProps', 'componentWillUnmount', 'hotComponentRender', 'getInitialState', 'getDefaultProps'];\nvar defaultRenderOptions = {\n  componentWillRender: identity,\n  componentDidUpdate: function componentDidUpdate(result) {\n    return result;\n  },\n  componentDidRender: function componentDidRender(result) {\n    return result;\n  }\n};\nvar filteredPrototypeMethods = function filteredPrototypeMethods(Proto) {\n  return Object.getOwnPropertyNames(Proto).filter(function (prop) {\n    var descriptor = Object.getOwnPropertyDescriptor(Proto, prop);\n    return descriptor && prop.indexOf(PREFIX) !== 0 && blackListedClassMembers.indexOf(prop) < 0 && typeof descriptor.value === 'function';\n  });\n};\nvar defineClassMember = function defineClassMember(Class, methodName, methodBody) {\n  return safeDefineProperty(Class.prototype, methodName, {\n    configurable: true,\n    writable: true,\n    enumerable: false,\n    value: methodBody\n  });\n};\nvar defineClassMembers = function defineClassMembers(Class, methods) {\n  return Object.keys(methods).forEach(function (methodName) {\n    return defineClassMember(Class, methodName, methods[methodName]);\n  });\n};\nvar setSFPFlag = function setSFPFlag(component, flag) {\n  return safeDefineProperty(component, 'isStatelessFunctionalProxy', {\n    configurable: false,\n    writable: false,\n    enumerable: false,\n    value: flag\n  });\n};\nvar copyMethodDescriptors = function copyMethodDescriptors(target, source) {\n  if (source) {\n    // it is possible to use `function-double` to construct an ideal clone, but does not make a sence\n    var keys = Object.getOwnPropertyNames(source);\n    keys.forEach(function (key) {\n      return safeDefineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n    safeDefineProperty(target, 'toString', {\n      configurable: true,\n      writable: false,\n      enumerable: false,\n      value: function toString() {\n        return String(source);\n      }\n    });\n  }\n  return target;\n};\nvar knownClassComponents = [];\nvar forEachKnownClass = function forEachKnownClass(cb) {\n  return knownClassComponents.forEach(cb);\n};\nfunction createClassProxy(InitialComponent, proxyKey) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var renderOptions = _extends({}, defaultRenderOptions, options);\n  var proxyConfig = _extends({}, configuration, options.proxy);\n  // Prevent double wrapping.\n  // Given a proxy class, return the existing proxy managing it.\n  var existingProxy = proxies.get(InitialComponent);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  var CurrentComponent = void 0;\n  var savedDescriptors = {};\n  var injectedMembers = {};\n  var proxyGeneration = 0;\n  var classUpdatePostponed = null;\n  var instancesCount = 0;\n  var isFunctionalComponent = !isReactClass(InitialComponent);\n  var lastInstance = null;\n  function postConstructionAction() {\n    this[GENERATION] = 0;\n    lastInstance = this;\n    // is there is an update pending\n    if (classUpdatePostponed) {\n      var callUpdate = classUpdatePostponed;\n      classUpdatePostponed = null;\n      callUpdate();\n    }\n    // As long we can't override constructor\n    // every class shall evolve from a base class\n    inject(this, proxyGeneration, injectedMembers);\n  }\n  function proxiedUpdate() {\n    if (this) {\n      inject(this, proxyGeneration, injectedMembers);\n    }\n  }\n  function lifeCycleWrapperFactory(wrapperName) {\n    var sideEffect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;\n    return copyMethodDescriptors(function wrappedMethod() {\n      proxiedUpdate.call(this);\n      sideEffect(this);\n      for (var _len = arguments.length, rest = Array(_len), _key = 0; _key < _len; _key++) {\n        rest[_key] = arguments[_key];\n      }\n      return !isFunctionalComponent && CurrentComponent.prototype[wrapperName] && CurrentComponent.prototype[wrapperName].apply(this, rest);\n    }, InitialComponent.prototype && InitialComponent.prototype[wrapperName]);\n  }\n  function methodWrapperFactory(wrapperName, realMethod) {\n    return copyMethodDescriptors(function wrappedMethod() {\n      for (var _len2 = arguments.length, rest = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        rest[_key2] = arguments[_key2];\n      }\n      return realMethod.apply(this, rest);\n    }, realMethod);\n  }\n  var fakeBasePrototype = function fakeBasePrototype(Proto) {\n    return filteredPrototypeMethods(Proto).reduce(function (acc, key) {\n      acc[key] = methodWrapperFactory(key, Proto[key]);\n      return acc;\n    }, {});\n  };\n  var componentDidMount = lifeCycleWrapperFactory('componentDidMount', function (target) {\n    target[PROXY_IS_MOUNTED] = true;\n    target[RENDERED_GENERATION] = get$1();\n    instancesCount++;\n  });\n  var componentDidUpdate = lifeCycleWrapperFactory('componentDidUpdate', renderOptions.componentDidUpdate);\n  var componentWillUnmount = lifeCycleWrapperFactory('componentWillUnmount', function (target) {\n    target[PROXY_IS_MOUNTED] = false;\n    instancesCount--;\n  });\n  function hotComponentRender() {\n    // repeating subrender call to keep RENDERED_GENERATION up to date\n    renderOptions.componentWillRender(this);\n    proxiedUpdate.call(this);\n    var result = void 0;\n\n    // We need to use hasOwnProperty here, as the cached result is a React node\n    // and can be null or some other falsy value.\n    if (has.call(this, CACHED_RESULT)) {\n      result = this[CACHED_RESULT];\n      delete this[CACHED_RESULT];\n    } else if (isFunctionalComponent) {\n      result = CurrentComponent(this.props, this.context);\n    } else {\n      var renderMethod = CurrentComponent.prototype.render || this.render;\n      /* eslint-disable no-use-before-define */\n      if (renderMethod === proxiedRender) {\n        throw new Error('React-Hot-Loader: you are trying to render Component without .render method');\n      }\n      /* eslint-enable */\n      result = renderMethod.apply(this,\n      // eslint-disable-next-line prefer-rest-params\n      arguments);\n    }\n    return renderOptions.componentDidRender.call(this, result);\n  }\n  function hotComponentUpdate() {\n    renderOptions.componentWillRender(this);\n    proxiedUpdate.call(this);\n  }\n  function proxiedRender() {\n    renderOptions.componentWillRender(this);\n    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    return hotComponentRender.call.apply(hotComponentRender, [this].concat(args));\n  }\n  var defineProxyMethods = function defineProxyMethods(Proxy) {\n    var Base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    defineClassMembers(Proxy, _extends({}, fakeBasePrototype(Base), proxyConfig.pureRender ? {} : {\n      render: proxiedRender\n    }, {\n      hotComponentRender: hotComponentRender,\n      hotComponentUpdate: hotComponentUpdate,\n      componentDidMount: componentDidMount,\n      componentDidUpdate: componentDidUpdate,\n      componentWillUnmount: componentWillUnmount\n    }));\n  };\n  var _ProxyFacade = void 0;\n  var ProxyComponent = null;\n  var proxy = void 0;\n  if (!isFunctionalComponent) {\n    // Component\n    ProxyComponent = proxyClassCreator(InitialComponent, postConstructionAction);\n    defineProxyMethods(ProxyComponent, InitialComponent.prototype);\n    knownClassComponents.push(ProxyComponent);\n    _ProxyFacade = ProxyComponent;\n  } else if (!proxyConfig.allowSFC) {\n    proxyConfig.pureRender = false;\n    // SFC Converted to component. Does not support returning precreated instances from render.\n    ProxyComponent = proxyClassCreator(React.Component, postConstructionAction);\n    defineProxyMethods(ProxyComponent);\n    _ProxyFacade = ProxyComponent;\n  } else {\n    // SFC\n\n    // This function only gets called for the initial mount. The actual\n    // rendered component instance will be the return value.\n\n    // eslint-disable-next-line func-names\n    _ProxyFacade = function ProxyFacade(props, context) {\n      /*\n         ! THIS IS NOT YOUR COMPONENT !\n        !  THIS IS REACT-HOT-LOADER  !\n         And you are probably looking for a function component of yours\n        It's hidden, but there is a way to fix this - just reconfigure your application a bit\n        see https://github.com/gaearon/react-hot-loader/issues/1311\n        */\n\n      var result = CurrentComponent(props, context);\n\n      // This is a Relay-style container constructor. We can't do the prototype-\n      // style wrapping for this as we do elsewhere, so just we just pass it\n      // through as-is.\n      if (isReactClassInstance(result)) {\n        ProxyComponent = null;\n\n        // Relay lazily sets statics like getDerivedStateFromProps on initial\n        // render in lazy construction, so we need to do the same here.\n        transferStaticProps(_ProxyFacade, savedDescriptors, null, CurrentComponent);\n        return result;\n      }\n\n      // simple SFC, could continue to be SFC\n      if (proxyConfig.pureSFC) {\n        if (!CurrentComponent.contextTypes) {\n          if (!_ProxyFacade.isStatelessFunctionalProxy) {\n            setSFPFlag(_ProxyFacade, true);\n          }\n          return renderOptions.componentDidRender(result);\n        }\n      }\n      setSFPFlag(_ProxyFacade, false);\n      proxyConfig.pureRender = false;\n\n      // Otherwise, it's a normal functional component. Build the real proxy\n      // and use it going forward.\n      ProxyComponent = proxyClassCreator(React.Component, postConstructionAction);\n      defineProxyMethods(ProxyComponent);\n      var determinateResult = new ProxyComponent(props, context);\n\n      // Cache the initial render result so we don't call the component function\n      // a second time for the initial render.\n      determinateResult[CACHED_RESULT] = result;\n      return determinateResult;\n    };\n  }\n  function get$$1() {\n    return _ProxyFacade;\n  }\n  function getCurrent() {\n    return CurrentComponent;\n  }\n  safeDefineProperty(_ProxyFacade, UNWRAP_PROXY, {\n    configurable: false,\n    writable: false,\n    enumerable: false,\n    value: getCurrent\n  });\n  safeDefineProperty(_ProxyFacade, PROXY_KEY, {\n    configurable: false,\n    writable: false,\n    enumerable: false,\n    value: proxyKey\n  });\n  safeDefineProperty(_ProxyFacade, 'toString', {\n    configurable: true,\n    writable: false,\n    enumerable: false,\n    value: function toString() {\n      return String(CurrentComponent);\n    }\n  });\n  function update(NextComponent) {\n    if (typeof NextComponent !== 'function') {\n      throw new Error('Expected a constructor.');\n    }\n    if (NextComponent === CurrentComponent) {\n      return false;\n    }\n\n    // Prevent proxy cycles\n    var existingProxy = proxies.get(NextComponent);\n    if (existingProxy) {\n      return false;\n    }\n    isFunctionalComponent = !isReactClass(NextComponent);\n    proxies.set(NextComponent, proxy);\n    proxyGeneration++;\n\n    // Save the next constructor so we call it\n    var PreviousComponent = CurrentComponent;\n    CurrentComponent = NextComponent;\n\n    // Try to infer displayName\n    var displayName = getComponentDisplayName(CurrentComponent);\n    safeDefineProperty(_ProxyFacade, 'displayName', {\n      configurable: true,\n      writable: false,\n      enumerable: true,\n      value: displayName\n    });\n    if (ProxyComponent) {\n      safeDefineProperty(ProxyComponent, 'name', {\n        value: displayName\n      });\n    }\n    savedDescriptors = transferStaticProps(_ProxyFacade, savedDescriptors, PreviousComponent, NextComponent);\n    if (isFunctionalComponent || !ProxyComponent) ;else {\n      var classHotReplacement = function classHotReplacement() {\n        checkLifeCycleMethods(ProxyComponent, NextComponent);\n        if (proxyGeneration > 1) {\n          getElementCloseHook(ProxyComponent);\n          filteredPrototypeMethods(ProxyComponent.prototype).forEach(function (methodName) {\n            if (!has.call(NextComponent.prototype, methodName)) {\n              delete ProxyComponent.prototype[methodName];\n            }\n          });\n        }\n        Object.setPrototypeOf(ProxyComponent.prototype, NextComponent.prototype);\n        defineProxyMethods(ProxyComponent, NextComponent.prototype);\n        if (proxyGeneration > 1) {\n          injectedMembers = mergeComponents(ProxyComponent, NextComponent, InitialComponent, lastInstance, injectedMembers);\n          getElementComparisonHook(ProxyComponent);\n        }\n      };\n\n      // Was constructed once\n      if (instancesCount > 0) {\n        classHotReplacement();\n      } else {\n        classUpdatePostponed = classHotReplacement;\n      }\n    }\n    return true;\n  }\n  update(InitialComponent);\n  var dereference = function dereference() {\n    proxies.delete(InitialComponent);\n    proxies.delete(_ProxyFacade);\n    proxies.delete(CurrentComponent);\n  };\n  proxy = {\n    get: get$$1,\n    update: update,\n    dereference: dereference,\n    getCurrent: function getCurrent() {\n      return CurrentComponent;\n    }\n  };\n  proxies.set(InitialComponent, proxy);\n  proxies.set(_ProxyFacade, proxy);\n  safeDefineProperty(proxy, UNWRAP_PROXY, {\n    configurable: false,\n    writable: false,\n    enumerable: false,\n    value: getCurrent\n  });\n  return proxy;\n}\n\n// this counter tracks `register` invocations.\n// works good, but code splitting is breaking it\nvar generation = 1;\n\n// these counters are aimed to mitigate the \"first render\"\nvar hotComparisonCounter = 0;\nvar hotComparisonRuns = 0;\nvar hotReplacementGeneration = 0;\nvar nullFunction = function nullFunction() {\n  return {};\n};\n\n// these callbacks would be called on component update\nvar onHotComparisonOpen = nullFunction;\nvar onHotComparisonElement = nullFunction;\nvar onHotComparisonClose = nullFunction;\n\n// inversion of control\nvar setComparisonHooks = function setComparisonHooks(open, element, close) {\n  onHotComparisonOpen = open;\n  onHotComparisonElement = element;\n  onHotComparisonClose = close;\n};\nvar getElementComparisonHook = function getElementComparisonHook(component) {\n  return onHotComparisonElement(component);\n};\nvar getElementCloseHook = function getElementCloseHook(component) {\n  return onHotComparisonClose(component);\n};\nvar hotComparisonOpen = function hotComparisonOpen() {\n  return hotComparisonCounter > 0 && hotComparisonRuns > 0 && hotReplacementGeneration > 0;\n};\nvar openGeneration = function openGeneration() {\n  return forEachKnownClass(onHotComparisonElement);\n};\nvar closeGeneration = function closeGeneration() {\n  return forEachKnownClass(onHotComparisonClose);\n};\nvar incrementHot = function incrementHot() {\n  if (!hotComparisonCounter) {\n    openGeneration();\n    onHotComparisonOpen();\n  }\n  hotComparisonCounter++;\n};\nvar decrementHot = function decrementHot() {\n  hotComparisonCounter--;\n  if (!hotComparisonCounter) {\n    closeGeneration();\n    hotComparisonRuns++;\n  }\n};\n\n// TODO: shall it be called from incrementHotGeneration?\nvar enterHotUpdate = function enterHotUpdate() {\n  Promise.resolve(incrementHot()).then(function () {\n    return setTimeout(decrementHot, 0);\n  });\n};\n\n// TODO: deprecate?\nvar increment = function increment() {\n  enterHotUpdate();\n  return generation++;\n};\nvar get$1 = function get() {\n  return generation;\n};\n\n// These counters tracks HMR generations, and probably should be used instead of the old one\nvar incrementHotGeneration = function incrementHotGeneration() {\n  return hotReplacementGeneration++;\n};\nvar getHotGeneration = function getHotGeneration() {\n  return hotReplacementGeneration;\n};\n\n// some `empty` names, React can autoset display name to...\nvar UNDEFINED_NAMES = {\n  Unknown: true,\n  Component: true\n};\nvar areNamesEqual = function areNamesEqual(a, b) {\n  return a === b || UNDEFINED_NAMES[a] && UNDEFINED_NAMES[b];\n};\nvar isFunctional = function isFunctional(fn) {\n  return typeof fn === 'function';\n};\nvar getTypeOf = function getTypeOf(type) {\n  if (isReactClass(type)) return 'ReactComponent';\n  if (isFunctional(type)) return 'StatelessFunctional';\n  return 'Fragment'; // ?\n};\nfunction clearStringFast(str) {\n  return str.length < 12 ? str : (' ' + str).slice(1);\n}\nvar haveTextSimilarity = function haveTextSimilarity(a, b) {\n  return (\n    // equal or slight changed\n    a === b || levenshtein.get(clearStringFast(a), clearStringFast(b)) < a.length * 0.2\n  );\n};\nvar getBaseProto = function getBaseProto(source) {\n  return source.prototype.hotComponentRender ? Object.getPrototypeOf(source.prototype) : source.prototype;\n};\nvar equalClasses = function equalClasses(a, b) {\n  var prototypeA = getBaseProto(a);\n  var prototypeB = getBaseProto(b);\n  var hits = 0;\n  var misses = 0;\n  var comparisons = 0;\n  Object.getOwnPropertyNames(prototypeA).forEach(function (key) {\n    var descriptorA = Object.getOwnPropertyDescriptor(prototypeA, key);\n    var valueA = descriptorA && (descriptorA.value || descriptorA.get || descriptorA.set);\n    var descriptorB = Object.getOwnPropertyDescriptor(prototypeB, key);\n    var valueB = descriptorB && (descriptorB.value || descriptorB.get || descriptorB.set);\n    if (typeof valueA === 'function' && key !== 'constructor') {\n      comparisons++;\n      if (haveTextSimilarity(String(valueA), String(valueB))) {\n        hits++;\n      } else {\n        misses++;\n        if (key === 'render') {\n          misses++;\n        }\n      }\n    }\n  });\n  // allow to add or remove one function\n  return hits > 0 && misses <= 1 || comparisons === 0;\n};\nvar areSwappable = function areSwappable(a, b) {\n  // both are registered components and have the same name\n  if (getIdByType(b) && getIdByType(a) === getIdByType(b)) {\n    return true;\n  }\n  if (getTypeOf(a) !== getTypeOf(b)) {\n    return false;\n  }\n  if (isReactClass(a)) {\n    return areNamesEqual(getComponentDisplayName(a), getComponentDisplayName(b)) && equalClasses(a, b);\n  }\n  if (isFunctional(a)) {\n    var nameA = getComponentDisplayName(a);\n    if (!areNamesEqual(nameA, getComponentDisplayName(b))) {\n      return false;\n    }\n    return nameA !== 'Component' || haveTextSimilarity(String(a), String(b));\n  }\n  return false;\n};\nfunction merge() {\n  var acc = {};\n  for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {\n    sources[_key] = arguments[_key];\n  }\n  for (var _iterator = sources, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n    var source = _ref;\n    if (source instanceof Array) {\n      if (!(acc instanceof Array)) {\n        acc = [];\n      }\n      acc = [].concat(acc, source);\n    } else if (source instanceof Object) {\n      for (var _iterator2 = Object.keys(source), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n        var _babelHelpers$extends;\n        var _ref2;\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref2 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref2 = _i2.value;\n        }\n        var key = _ref2;\n        var value = source[key];\n        if (value instanceof Object && key in acc) {\n          value = merge(acc[key], value);\n        }\n        acc = _extends({}, acc, (_babelHelpers$extends = {}, _babelHelpers$extends[key] = value, _babelHelpers$extends));\n      }\n    }\n  }\n  return acc;\n}\nvar signatures = void 0;\nvar proxiesByID = void 0;\nvar blackListedProxies = void 0;\nvar registeredComponents = void 0;\nvar idsByType = void 0;\nvar elementCount = 0;\nvar renderOptions = {};\nvar componentOptions = void 0;\nvar generateTypeId = function generateTypeId() {\n  return 'auto-' + elementCount++;\n};\nvar getIdByType = function getIdByType(type) {\n  return idsByType.get(type);\n};\nvar isProxyType = function isProxyType(type) {\n  return type[PROXY_KEY];\n};\nvar getProxyById = function getProxyById(id) {\n  return proxiesByID[id];\n};\nvar getProxyByType = function getProxyByType(type) {\n  return getProxyById(getIdByType(type));\n};\nvar registerComponent = function registerComponent(type) {\n  return registeredComponents.set(type, 1);\n};\nvar isRegisteredComponent = function isRegisteredComponent(type) {\n  return registeredComponents.has(type);\n};\nvar setStandInOptions = function setStandInOptions(options) {\n  renderOptions = options;\n};\nvar updateFunctionProxyById = function updateFunctionProxyById(id, type, updater) {\n  // Remember the ID.\n  idsByType.set(type, id);\n  var proxy = proxiesByID[id];\n  if (!proxy) {\n    proxiesByID[id] = type;\n  }\n  updater(proxiesByID[id], type);\n  // proxiesByID[id] = type; // keep the first ref\n\n  return proxiesByID[id];\n};\nvar updateProxyById = function updateProxyById(id, type) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!id) {\n    return null;\n  }\n  // Remember the ID.\n  idsByType.set(type, id);\n  if (!proxiesByID[id]) {\n    proxiesByID[id] = createClassProxy(type, id, merge({}, renderOptions, {\n      proxy: componentOptions.get(type) || {}\n    }, options));\n  } else if (proxiesByID[id].update(type)) {\n    // proxy could be registered again only in case of HMR\n    incrementHotGeneration();\n  }\n  return proxiesByID[id];\n};\nvar createProxyForType = function createProxyForType(type, options) {\n  return getProxyByType(type) || updateProxyById(generateTypeId(), type, options);\n};\nvar isColdType = function isColdType(type) {\n  return blackListedProxies.has(type);\n};\nvar isTypeBlacklisted = function isTypeBlacklisted(type) {\n  return isColdType(type) || isCompositeComponent(type) && (configuration.ignoreSFC && !isReactClass(type) || configuration.ignoreComponents && isReactClass(type));\n};\nvar blacklistByType = function blacklistByType(type) {\n  return blackListedProxies.set(type, true);\n};\nvar setComponentOptions = function setComponentOptions(component, options) {\n  return componentOptions.set(component, options);\n};\nvar addSignature = function addSignature(type, signature) {\n  return signatures.set(type, signature);\n};\nvar getSignature = function getSignature(type) {\n  return signatures.get(type);\n};\nvar resetProxies = function resetProxies() {\n  proxiesByID = {};\n  idsByType = new WeakMap();\n  blackListedProxies = new WeakMap();\n  registeredComponents = new WeakMap();\n  componentOptions = new WeakMap();\n  signatures = new WeakMap();\n  resetClassProxies();\n};\nresetProxies();\nvar tune = {\n  allowSFC: false\n};\nvar preactAdapter = function preactAdapter(instance, resolveType) {\n  var oldHandler = instance.options.vnode;\n  setConfiguration(tune);\n  instance.options.vnode = function (vnode) {\n    if (vnode.type) {\n      vnode.type = resolveType(vnode.type);\n    } else if (vnode.nodeName) {\n      vnode.nodeName = resolveType(vnode.nodeName);\n    }\n    if (oldHandler) {\n      oldHandler(vnode);\n    }\n  };\n};\n\n/* global document */\n\nvar lastError = [];\nvar overlayStyle = {\n  position: 'fixed',\n  left: 0,\n  top: 0,\n  right: 0,\n  backgroundColor: 'rgba(255,200,200,0.9)',\n  color: '#000',\n  fontFamily: '-apple-system, BlinkMacSystemFont, \"Segoe UI\", \"Roboto\", \"Oxygen\", \"Ubuntu\", \"Fira Sans\", \"Droid Sans\", \"Helvetica Neue\", sans-serif',\n  fontSize: '12px',\n  margin: 0,\n  padding: '16px',\n  maxHeight: '50%',\n  overflow: 'auto',\n  zIndex: 10000\n};\nvar inlineErrorStyle = {\n  backgroundColor: '#FEE'\n};\nvar liCounter = {\n  position: 'absolute',\n  left: '10px'\n};\nvar listStyle = {};\nvar EmptyErrorPlaceholder = function EmptyErrorPlaceholder(_ref) {\n  var component = _ref.component;\n  return React__default.createElement('span', {\n    style: inlineErrorStyle,\n    role: 'img',\n    'aria-label': 'Rect-Hot-Loader Error'\n  }, '\\u269B\\uFE0F\\uD83D\\uDD25\\uD83E\\uDD15 (', component ? getComponentDisplayName(component.constructor || component) : 'Unknown location', ')', component && component.retryHotLoaderError && React__default.createElement('button', {\n    onClick: function onClick() {\n      return component.retryHotLoaderError();\n    },\n    title: 'Retry'\n  }, '\\u27F3'));\n};\nvar errorHeader = function errorHeader(component, componentStack) {\n  if (component || componentStack) {\n    return React__default.createElement('span', null, '(', component ? getComponentDisplayName(component.constructor || component) : 'Unknown location', component && ', ', componentStack && componentStack.split('\\n').filter(Boolean)[0], ')');\n  }\n  return null;\n};\nvar mapError = function mapError(_ref2) {\n  var error = _ref2.error,\n    errorInfo = _ref2.errorInfo,\n    component = _ref2.component;\n  if (!error) {\n    error = {\n      message: 'undefined error'\n    };\n  }\n  return React__default.createElement(React__default.Fragment, null, React__default.createElement('p', {\n    style: {\n      color: 'red'\n    }\n  }, errorHeader(component, errorInfo && errorInfo.componentStack), ' ', error.toString ? error.toString() : error && error.message || 'undefined error'), errorInfo && errorInfo.componentStack ? React__default.createElement('div', null, React__default.createElement('div', null, 'Stack trace:'), React__default.createElement('ul', {\n    style: {\n      color: 'red',\n      marginTop: '10px'\n    }\n  }, error.stack.split('\\n').slice(1, 2).map(function (line, i) {\n    return React__default.createElement('li', {\n      key: String(i)\n    }, line);\n  }), React__default.createElement('hr', null), errorInfo.componentStack.split('\\n').filter(Boolean).map(function (line, i) {\n    return React__default.createElement('li', {\n      key: String(i)\n    }, line);\n  }))) : error.stack && React__default.createElement('div', null, React__default.createElement('div', null, 'Stack trace:'), React__default.createElement('ul', {\n    style: {\n      color: 'red',\n      marginTop: '10px'\n    }\n  }, error.stack.split('\\n').map(function (line, i) {\n    return React__default.createElement('li', {\n      key: String(i)\n    }, line);\n  }))));\n};\nvar ErrorOverlay = function (_React$Component) {\n  inherits(ErrorOverlay, _React$Component);\n  function ErrorOverlay() {\n    var _temp, _this, _ret;\n    classCallCheck(this, ErrorOverlay);\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {\n      visible: true\n    }, _this.toggle = function () {\n      return _this.setState({\n        visible: !_this.state.visible\n      });\n    }, _this.retry = function () {\n      return _this.setState(function () {\n        var errors = _this.props.errors;\n        enterHotUpdate();\n        clearExceptions();\n        errors.map(function (_ref3) {\n          var component = _ref3.component;\n          return component;\n        }).filter(Boolean).filter(function (_ref4) {\n          var retryHotLoaderError = _ref4.retryHotLoaderError;\n          return !!retryHotLoaderError;\n        }).forEach(function (component) {\n          return component.retryHotLoaderError();\n        });\n        return {};\n      });\n    }, _temp), possibleConstructorReturn(_this, _ret);\n  }\n  ErrorOverlay.prototype.render = function render() {\n    var errors = this.props.errors;\n    if (!errors.length) {\n      return null;\n    }\n    var visible = this.state.visible;\n    return React__default.createElement('div', {\n      style: overlayStyle\n    }, React__default.createElement('h2', {\n      style: {\n        margin: 0\n      }\n    }, '\\u269B\\uFE0F\\uD83D\\uDD25\\uD83D\\uDE2D: hot update was not successful ', React__default.createElement('button', {\n      onClick: this.toggle\n    }, visible ? 'collapse' : 'expand'), React__default.createElement('button', {\n      onClick: this.retry\n    }, 'Retry')), visible && React__default.createElement('ul', {\n      style: listStyle\n    }, errors.map(function (err, i) {\n      return React__default.createElement('li', {\n        key: i\n      }, React__default.createElement('span', {\n        style: liCounter\n      }, '(', i + 1, '/', errors.length, ')'), mapError(err));\n    })));\n  };\n  return ErrorOverlay;\n}(React__default.Component);\nvar initErrorOverlay = function initErrorOverlay() {\n  if (typeof document === 'undefined' || !document.body) {\n    return;\n  }\n  var div = document.querySelector('.react-hot-loader-error-overlay');\n  if (!div) {\n    div = document.createElement('div');\n    div.className = 'react-hot-loader-error-overlay';\n    document.body.appendChild(div);\n  }\n  if (lastError.length) {\n    var Overlay = configuration.ErrorOverlay || ErrorOverlay;\n    ReactDOM.render(React__default.createElement(Overlay, {\n      errors: lastError\n    }), div);\n  } else {\n    div.parentNode.removeChild(div);\n  }\n};\nfunction clearExceptions() {\n  if (lastError.length) {\n    lastError = [];\n    initErrorOverlay();\n  }\n}\nfunction logException(error, errorInfo, component) {\n  // do not suppress error\n\n  /* eslint-disable no-console */\n  console.error(error);\n  /* eslint-enable */\n\n  lastError.push({\n    error: error,\n    errorInfo: errorInfo,\n    component: component\n  });\n  initErrorOverlay();\n}\n\n/* eslint-disable no-underscore-dangle */\n\nvar hotRenderWithHooks = ReactDOM.hotRenderWithHooks || function (fiber, render) {\n  return render();\n};\nfunction pushStack(stack, node) {\n  stack.type = node.type;\n  stack.elementType = node.elementType || node.type;\n  stack.children = [];\n  stack.instance = typeof node.type === 'function' ? node.stateNode : stack;\n  stack.fiber = node;\n  if (!stack.instance) {\n    stack.instance = {\n      SFC_fake: stack.type,\n      props: {},\n      render: function render() {\n        return hotRenderWithHooks(node, function () {\n          return stack.type(stack.instance.props);\n        });\n      }\n    };\n  }\n}\nfunction hydrateFiberStack(node, stack) {\n  pushStack(stack, node);\n  if (node.child) {\n    var child = node.child;\n    do {\n      var childStack = {};\n      hydrateFiberStack(child, childStack);\n      stack.children.push(childStack);\n      child = child.sibling;\n    } while (child);\n  }\n}\n\n/* eslint-disable no-underscore-dangle */\n\nfunction pushState(stack, type, instance) {\n  stack.type = type;\n  stack.elementType = type;\n  stack.children = [];\n  stack.instance = instance || stack;\n  if (typeof type === 'function' && type.isStatelessFunctionalProxy) {\n    // In React 15 SFC is wrapped by component. We have to detect our proxies and change the way it works\n    stack.instance = {\n      SFC_fake: type,\n      props: {},\n      render: function render() {\n        return type(stack.instance.props);\n      }\n    };\n  }\n}\nfunction hydrateLegacyStack(node, stack) {\n  if (node._currentElement) {\n    pushState(stack, node._currentElement.type, node._instance || stack);\n  }\n  if (node._renderedComponent) {\n    var childStack = {};\n    hydrateLegacyStack(node._renderedComponent, childStack);\n    stack.children.push(childStack);\n  } else if (node._renderedChildren) {\n    Object.keys(node._renderedChildren).forEach(function (key) {\n      var childStack = {};\n      hydrateLegacyStack(node._renderedChildren[key], childStack);\n      stack.children.push(childStack);\n    });\n  }\n}\nvar shouldNotPatchComponent = function shouldNotPatchComponent(type) {\n  return isTypeBlacklisted(type);\n};\nfunction resolveUtility(type) {\n  // all \"utility\" types are resolved to their __initial__ shapes\n  // that enables to never change reference to them, and gives the ability to maintain React Tree on HMR\n\n  // all operations could be skipped with react-hot-dom enabled\n\n  if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object') {\n    if (configuration.integratedComparator) {\n      return type;\n    }\n    var element = {\n      type: type\n    };\n    if (isLazyType(element) || isMemoType(element) || isForwardType(element) || isContextType(element)) {\n      return getProxyByType(type) || type;\n    }\n  }\n  return undefined;\n}\nfunction resolveComponent(type) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var existingProxy = getProxyByType(type);\n\n  // cold API\n  if (shouldNotPatchComponent(type)) {\n    return existingProxy ? existingProxy.getCurrent() : type;\n  }\n  if (!existingProxy && configuration.onComponentCreate) {\n    configuration.onComponentCreate(type, getComponentDisplayName(type));\n    if (shouldNotPatchComponent(type)) {\n      return type;\n    }\n  }\n  var proxy = internalConfiguration.disableProxyCreation ? existingProxy : createProxyForType(type, options);\n  return proxy ? proxy.get() : undefined;\n}\nfunction resolveProxy(type) {\n  if (isProxyType(type)) {\n    return type;\n  }\n  return undefined;\n}\nfunction resolveNotComponent(type) {\n  if (!isCompositeComponent(type)) {\n    return type;\n  }\n  return undefined;\n}\nvar getLatestTypeVersion = function getLatestTypeVersion(type) {\n  var existingProxy = getProxyByType(type);\n  return existingProxy && existingProxy.getCurrent && existingProxy.getCurrent();\n};\nvar resolveSimpleType = function resolveSimpleType(type) {\n  if (!type) {\n    return type;\n  }\n  var simpleResult = resolveProxy(type) || resolveUtility(type) || resolveNotComponent(type);\n  if (simpleResult) {\n    return simpleResult;\n  }\n  var lastType = getLatestTypeVersion(type);\n\n  // only lazy loaded components any now failing into this branch\n\n  // if (lastType && lastType !== type) {\n  //   console.warn('RHL: used type', type, 'is obsolete. Something is wrong with HMR.');\n  // }\n\n  return lastType || type;\n};\nvar resolveType = function resolveType(type) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!type) {\n    return type;\n  }\n  return resolveProxy(type) || resolveUtility(type) || resolveNotComponent(type) || resolveComponent(type, options) || type;\n};\n\n/* eslint-disable no-underscore-dangle */\n\nfunction getReactStack(instance) {\n  var rootNode = getInternalInstance(instance);\n  var stack = {};\n  if (rootNode) {\n    // React stack\n    var isFiber = typeof rootNode.tag === 'number';\n    if (isFiber) {\n      hydrateFiberStack(rootNode, stack);\n    } else {\n      hydrateLegacyStack(rootNode, stack);\n    }\n  }\n  return stack;\n}\nvar markUpdate = function markUpdate(_ref) {\n  var fiber = _ref.fiber;\n\n  // do not update what we should not\n  if (!fiber || typeof fiber.type === 'string') {\n    return;\n  }\n  var mostResentType = resolveType(fiber.type) || fiber.type;\n  fiber.type = mostResentType;\n  // do not change fiber.elementType to keep old information for the hot-update\n\n  fiber.expirationTime = 1;\n  if (fiber.alternate) {\n    fiber.alternate.expirationTime = 1;\n    fiber.alternate.type = fiber.type;\n  }\n  if (fiber.memoizedProps && _typeof(fiber.memoizedProps) === 'object') {\n    fiber.memoizedProps = _extends({\n      cacheBusterProp: true\n    }, fiber.memoizedProps);\n  }\n  if (fiber.stateNode) ;\n};\nvar cleanupReact = function cleanupReact() {\n  if (ReactDOM.hotCleanup) {\n    ReactDOM.hotCleanup();\n  }\n};\nvar deepMarkUpdate = function deepMarkUpdate(stack) {\n  markUpdate(stack);\n  if (stack.children) {\n    stack.children.forEach(deepMarkUpdate);\n  }\n};\nvar renderStack = [];\nvar stackReport = function stackReport() {\n  var rev = renderStack.slice().reverse();\n  logger.warn('in', rev[0].name, rev);\n};\nvar emptyMap = new Map();\nvar stackContext = function stackContext() {\n  return (renderStack[renderStack.length - 1] || {}).context || emptyMap;\n};\nvar shouldUseRenderMethod = function shouldUseRenderMethod(fn) {\n  return fn && (isReactClassInstance(fn) || fn.SFC_fake);\n};\nvar getElementType$1 = function getElementType$$1(child) {\n  return child.type[UNWRAP_PROXY] ? child.type[UNWRAP_PROXY]() : child.type;\n};\nvar filterNullArray = function filterNullArray(a) {\n  if (!a) return [];\n  return a.filter(function (x) {\n    return !!x;\n  });\n};\nvar unflatten = function unflatten(a) {\n  return a.reduce(function (acc, a) {\n    if (Array.isArray(a)) {\n      acc.push.apply(acc, unflatten(a));\n    } else {\n      acc.push(a);\n    }\n    return acc;\n  }, []);\n};\nvar isArray = function isArray(fn) {\n  return Array.isArray(fn);\n};\nvar asArray = function asArray(a) {\n  return isArray(a) ? a : [a];\n};\nvar render = function render(component, stack) {\n  if (!component) {\n    return [];\n  }\n  if (component.hotComponentUpdate) {\n    component.hotComponentUpdate();\n  }\n  if (shouldUseRenderMethod(component)) {\n    // not calling real render method to prevent call recursion.\n    // stateless components does not have hotComponentRender\n    return component.hotComponentRender ? component.hotComponentRender() : component.render();\n  }\n  if (isForwardType(component)) {\n    // render forward type in a sandbox\n    return hotRenderWithHooks(stack.fiber, function () {\n      return component.type.render(component.props, null);\n    });\n  }\n  if (isArray(component)) {\n    return component.map(render);\n  }\n  if (component.children) {\n    return component.children;\n  }\n  return [];\n};\nvar NO_CHILDREN = {\n  children: []\n};\nvar mapChildren = function mapChildren(children, instances) {\n  return {\n    children: children.filter(function (c) {\n      return c;\n    }).map(function (child, index) {\n      if ((typeof child === 'undefined' ? 'undefined' : _typeof(child)) !== 'object' || child.isMerged) {\n        return child;\n      }\n      var instanceLine = instances[index] || {};\n      var oldChildren = asArray(instanceLine.children || []);\n      if (Array.isArray(child)) {\n        return _extends({\n          type: null\n        }, mapChildren(child, oldChildren));\n      }\n      var newChildren = asArray(child.props && child.props.children || child.children || []);\n      var nextChildren = child.type !== 'function' && oldChildren.length && mapChildren(newChildren, oldChildren);\n      return _extends({\n        nextProps: child.props,\n        isMerged: true\n      }, instanceLine, nextChildren || {}, {\n        type: child.type\n      });\n    })\n  };\n};\nvar mergeInject = function mergeInject(a, b, instance) {\n  if (a && !Array.isArray(a)) {\n    return mergeInject([a], b);\n  }\n  if (b && !Array.isArray(b)) {\n    return mergeInject(a, [b]);\n  }\n  if (!a || !b) {\n    return NO_CHILDREN;\n  }\n  if (a.length === b.length) {\n    return mapChildren(a, b);\n  }\n\n  // in some cases (no confidence here) B could contain A except null children\n  // in some cases - could not.\n  // this depends on React version and the way you build component.\n\n  var nonNullA = filterNullArray(a);\n  if (nonNullA.length === b.length) {\n    return mapChildren(nonNullA, b);\n  }\n  var flatA = unflatten(nonNullA);\n  var flatB = unflatten(b);\n  if (flatA.length === flatB.length) {\n    return mapChildren(flatA, flatB);\n  }\n  if (flatB.length === 0 && flatA.length === 1 && _typeof(flatA[0]) !== 'object') ;else if (!configuration.IS_REACT_MERGE_ENABLED) {\n    logger.warn('React-hot-loader: unable to merge ', a, 'and children of ', instance);\n    stackReport();\n  }\n  return NO_CHILDREN;\n};\nvar transformFlowNode = function transformFlowNode(flow) {\n  return flow.reduce(function (acc, node) {\n    if (node && isFragmentNode(node)) {\n      if (node.props && node.props.children) {\n        return [].concat(acc, filterNullArray(asArray(node.props.children)));\n      }\n      if (node.children) {\n        return [].concat(acc, filterNullArray(asArray(node.children)));\n      }\n    }\n    return [].concat(acc, [node]);\n  }, []);\n};\nvar scheduledUpdates = [];\nvar scheduledUpdate = 0;\nvar flushScheduledUpdates = function flushScheduledUpdates() {\n  var instances = scheduledUpdates;\n  scheduledUpdates = [];\n  scheduledUpdate = 0;\n  instances.forEach(function (instance) {\n    return instance[PROXY_IS_MOUNTED] && updateInstance(instance);\n  });\n};\nvar unscheduleUpdate = function unscheduleUpdate(instance) {\n  scheduledUpdates = scheduledUpdates.filter(function (inst) {\n    return inst !== instance;\n  });\n};\nvar scheduleInstanceUpdate = function scheduleInstanceUpdate(instance) {\n  scheduledUpdates.push(instance);\n  if (!scheduledUpdate) {\n    scheduledUpdate = setTimeout(flushScheduledUpdates, 4);\n  }\n};\nvar hotReplacementRender = function hotReplacementRender(instance, stack) {\n  if (isReactClassInstance(instance)) {\n    var type = getElementType$1(stack);\n    renderStack.push({\n      name: getComponentDisplayName(type),\n      type: type,\n      props: stack.instance.props,\n      context: stackContext()\n    });\n  }\n  try {\n    var flow = transformFlowNode(filterNullArray(asArray(render(instance, stack))));\n    var children = stack.children;\n    flow.forEach(function (child, index) {\n      var childType = child.type;\n      var stackChild = children[index];\n      var next = function next(instance) {\n        // copy over props as long new component may be hidden inside them\n        // child does not have all props, as long some of them can be calculated on componentMount.\n        var realProps = instance.props;\n        var nextProps = _extends({}, realProps, child.nextProps || {}, child.props || {});\n        if (isReactClassInstance(instance) && instance.componentWillUpdate) {\n          // Force-refresh component (bypass redux renderedComponent)\n          instance.componentWillUpdate(_extends({}, realProps), instance.state);\n        }\n        instance.props = nextProps;\n        hotReplacementRender(instance, stackChild);\n        instance.props = realProps;\n      };\n\n      // text node\n      if ((typeof child === 'undefined' ? 'undefined' : _typeof(child)) !== 'object' || !stackChild || !stackChild.instance) {\n        if (stackChild && stackChild.children && stackChild.children.length) {\n          logger.error('React-hot-loader: reconciliation failed', 'could not dive into [', child, '] while some elements are still present in the tree.');\n          stackReport();\n        }\n        return;\n      }\n\n      // comparing rendered type to fiber.ElementType\n      if ((typeof childType === 'undefined' ? 'undefined' : _typeof(childType)) !== _typeof(stackChild.elementType)) {\n        // Portals could generate undefined !== null\n        if (childType && stackChild.type) {\n          logger.warn('React-hot-loader: got ', childType, 'instead of', stackChild.type);\n          stackReport();\n        }\n        return;\n      }\n      if (isMemoType(child) || isLazyType(child)) {\n        // force update memo children\n        if (stackChild.children && stackChild.children[0]) {\n          scheduleInstanceUpdate(stackChild.children[0].instance);\n        }\n        childType = childType.type || childType;\n      }\n      if (isForwardType(child)) {\n        next(stackChild.instance);\n      } else if (isContextConsumer(child)) {\n        try {\n          var contextValue = stackContext().get(getContextProvider(childType));\n          next({\n            children: (child.props ? child.props.children : child.children[0])(contextValue !== undefined ? contextValue : childType[CONTEXT_CURRENT_VALUE])\n          });\n        } catch (e) {\n          // do nothing, yet\n        }\n      } else if (typeof childType !== 'function') {\n        // React\n        var childName = childType ? getComponentDisplayName(childType) : 'empty';\n        var extraContext = stackContext();\n        if (isContextProvider(child)) {\n          extraContext = new Map(extraContext);\n          extraContext.set(getContextProvider(childType), _extends({}, child.nextProps || {}, child.props || {}).value);\n          childName = 'ContextProvider';\n        }\n        renderStack.push({\n          name: childName,\n          type: childType,\n          props: stack.instance.props,\n          context: extraContext\n        });\n        next(\n        // move types from render to the instances of hydrated tree\n        mergeInject(transformFlowNode(asArray(child.props ? child.props.children : child.children)), stackChild.instance.children, stackChild.instance));\n        renderStack.pop();\n      } else {\n        if (childType === stackChild.type) {\n          next(stackChild.instance);\n        } else {\n          // unwrap proxy\n          var _childType = getElementType$1(child);\n          if (isMemoType(child)) {\n            _childType = _childType.type || _childType;\n          }\n          if (!stackChild.type[PROXY_KEY]) {\n            if (!configuration.IS_REACT_MERGE_ENABLED) {\n              if (isTypeBlacklisted(stackChild.type)) {\n                logger.warn('React-hot-loader: cold element got updated ', stackChild.type);\n              }\n            }\n          }\n          if (isRegisteredComponent(_childType) || isRegisteredComponent(stackChild.type)) {\n            // one of elements are registered via babel plugin, and should not be handled by hot swap\n            if (resolveType(_childType) === resolveType(stackChild.type)) {\n              next(stackChild.instance);\n            }\n          } else if (areSwappable(_childType, stackChild.type)) {\n            // they are both registered, or have equal code/displayname/signature\n\n            // update proxy using internal PROXY_KEY\n            updateProxyById(stackChild.type[PROXY_KEY] || getIdByType(stackChild.type), _childType);\n            next(stackChild.instance);\n          } else {\n            logger.warn('React-hot-loader: a ' + getComponentDisplayName(_childType) + ' was found where a ' + getComponentDisplayName(stackChild) + ' was expected.\\n          ' + _childType);\n            stackReport();\n          }\n        }\n        scheduleInstanceUpdate(stackChild.instance);\n      }\n    });\n  } catch (e) {\n    if (e.then) ;else {\n      logger.warn('React-hot-loader: run time error during reconciliation', e);\n    }\n  }\n  if (isReactClassInstance(instance)) {\n    renderStack.pop();\n  }\n};\nvar hotReplacementRender$1 = function (instance, stack) {\n  if (configuration.disableHotRenderer) {\n    return;\n  }\n  try {\n    // disable reconciler to prevent upcoming components from proxying.\n    internalConfiguration.disableProxyCreation = true;\n    renderStack = [];\n    hotReplacementRender(instance, stack);\n  } catch (e) {\n    logger.warn('React-hot-loader: reconcilation failed due to error', e);\n  } finally {\n    internalConfiguration.disableProxyCreation = false;\n  }\n};\nvar reconcileHotReplacement = function reconcileHotReplacement(ReactInstance) {\n  var stack = getReactStack(ReactInstance);\n  hotReplacementRender$1(ReactInstance, stack);\n  cleanupReact();\n  deepMarkUpdate(stack);\n};\nvar renderReconciler = function renderReconciler(target, force) {\n  // we are not inside parent reconcilation\n  var currentGeneration = get$1();\n  var componentGeneration = target[RENDERED_GENERATION];\n  target[RENDERED_GENERATION] = currentGeneration;\n  if (!internalConfiguration.disableProxyCreation) {\n    if ((componentGeneration || force) && componentGeneration !== currentGeneration) {\n      enterHotUpdate();\n      reconcileHotReplacement(target);\n      return true;\n    }\n  }\n  return false;\n};\nfunction asyncReconciledRender(target) {\n  renderReconciler(target, false);\n}\nfunction proxyWrapper(element) {\n  // post wrap on post render\n  if (!internalConfiguration.disableProxyCreation) {\n    unscheduleUpdate(this);\n  }\n  if (!element) {\n    return element;\n  }\n  if (Array.isArray(element)) {\n    return element.map(proxyWrapper);\n  }\n  if (typeof element.type === 'function') {\n    var proxy = getProxyByType(element.type);\n    if (proxy) {\n      return _extends({}, element, {\n        type: proxy.get()\n      });\n    }\n  }\n  return element;\n}\nvar ERROR_STATE = 'react_hot_loader_catched_error';\nvar ERROR_STATE_PROTO = 'react_hot_loader_catched_error-prototype';\nvar OLD_RENDER = 'react_hot_loader_original_render';\nfunction componentDidCatch(error, errorInfo) {\n  this[ERROR_STATE] = {\n    location: 'boundary',\n    error: error,\n    errorInfo: errorInfo,\n    generation: get$1()\n  };\n  Object.getPrototypeOf(this)[ERROR_STATE_PROTO] = this[ERROR_STATE];\n  if (!configuration.errorReporter) {\n    logException(error, errorInfo, this);\n  }\n  this.forceUpdate();\n}\nfunction componentRender() {\n  var _ref = this[ERROR_STATE] || {},\n    error = _ref.error,\n    errorInfo = _ref.errorInfo,\n    generation = _ref.generation;\n  if (error && generation === get$1()) {\n    return React__default.createElement(configuration.errorReporter || EmptyErrorPlaceholder, {\n      error: error,\n      errorInfo: errorInfo,\n      component: this\n    });\n  }\n  if (this.hotComponentUpdate) {\n    this.hotComponentUpdate();\n  }\n  try {\n    var _OLD_RENDER$render;\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return (_OLD_RENDER$render = this[OLD_RENDER].render).call.apply(_OLD_RENDER$render, [this].concat(args));\n  } catch (renderError) {\n    this[ERROR_STATE] = {\n      location: 'render',\n      error: renderError,\n      generation: get$1()\n    };\n    if (!configuration.errorReporter) {\n      logException(renderError, undefined, this);\n    }\n    return componentRender.call(this);\n  }\n}\nfunction retryHotLoaderError() {\n  delete this[ERROR_STATE];\n  this.forceUpdate();\n}\nsetComparisonHooks(function () {\n  return {};\n}, function (component) {\n  if (!hotComparisonOpen()) {\n    return;\n  }\n  var prototype = component.prototype;\n  if (!prototype[OLD_RENDER]) {\n    var renderDescriptior = Object.getOwnPropertyDescriptor(prototype, 'render');\n    prototype[OLD_RENDER] = {\n      descriptor: renderDescriptior ? renderDescriptior.value : undefined,\n      render: prototype.render\n    };\n    prototype.componentDidCatch = componentDidCatch;\n    prototype.retryHotLoaderError = retryHotLoaderError;\n    prototype.render = componentRender;\n  }\n  delete prototype[ERROR_STATE];\n}, function (_ref2) {\n  var prototype = _ref2.prototype;\n  if (prototype[OLD_RENDER]) {\n    var _ref3 = prototype[ERROR_STATE_PROTO] || {},\n      generation = _ref3.generation;\n    if (generation === get$1()) ;else {\n      delete prototype.componentDidCatch;\n      delete prototype.retryHotLoaderError;\n\n      // undo only what we did\n      if (prototype.render === componentRender) {\n        if (!prototype[OLD_RENDER].descriptor) {\n          delete prototype.render;\n        } else {\n          prototype.render = prototype[OLD_RENDER].descriptor;\n        }\n      } else {\n        console.error('React-Hot-Loader: something unexpectedly mutated Component', prototype);\n      }\n      delete prototype[ERROR_STATE_PROTO];\n      delete prototype[OLD_RENDER];\n    }\n  }\n});\nsetStandInOptions({\n  componentWillRender: asyncReconciledRender,\n  componentDidRender: proxyWrapper,\n  componentDidUpdate: function componentDidUpdate(component) {\n    component[RENDERED_GENERATION] = get$1();\n    flushScheduledUpdates();\n  }\n});\nvar AppContainer = function (_React$Component) {\n  inherits(AppContainer, _React$Component);\n  AppContainer.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n    if (prevState.generation !== get$1()) {\n      // Hot reload is happening.\n      return {\n        error: null,\n        generation: get$1()\n      };\n    }\n    return null;\n  };\n  function AppContainer(props) {\n    classCallCheck(this, AppContainer);\n    var _this = possibleConstructorReturn(this, _React$Component.call(this, props));\n    if (configuration.showReactDomPatchNotification) {\n      configuration.showReactDomPatchNotification = false;\n      console.warn('React-Hot-Loader: react-🔥-dom patch is not detected. React 16.6+ features may not work.');\n    }\n    _this.state = {\n      error: null,\n      errorInfo: null,\n      // eslint-disable-next-line react/no-unused-state\n      generation: 0\n    };\n    return _this;\n  }\n  AppContainer.prototype.shouldComponentUpdate = function shouldComponentUpdate(prevProps, prevState) {\n    // Don't update the component if the state had an error and still has one.\n    // This allows to break an infinite loop of error -> render -> error -> render\n    // https://github.com/gaearon/react-hot-loader/issues/696\n    if (prevState.error && this.state.error) {\n      return false;\n    }\n    return true;\n  };\n  AppContainer.prototype.componentDidCatch = function componentDidCatch(error, errorInfo) {\n    logger.error(error);\n    if (!hotComparisonOpen()) {\n      // do not log error outside of HMR cycle\n\n      // trigger update to kick error\n      this.setState({});\n      throw error;\n    }\n    var _props$errorReporter = this.props.errorReporter,\n      errorReporter = _props$errorReporter === undefined ? configuration.errorReporter : _props$errorReporter;\n    if (!errorReporter) {\n      logException(error, errorInfo, this);\n    }\n    this.setState({\n      error: error,\n      errorInfo: errorInfo\n    });\n  };\n  AppContainer.prototype.retryHotLoaderError = function retryHotLoaderError$$1() {\n    var _this2 = this;\n    this.setState({\n      error: null\n    }, function () {\n      retryHotLoaderError.call(_this2);\n    });\n  };\n  AppContainer.prototype.render = function render() {\n    var _state = this.state,\n      error = _state.error,\n      errorInfo = _state.errorInfo;\n    var _props$errorReporter2 = this.props.errorReporter,\n      ErrorReporter = _props$errorReporter2 === undefined ? configuration.errorReporter || EmptyErrorPlaceholder : _props$errorReporter2;\n    if (error && this.props.errorBoundary) {\n      return React__default.createElement(ErrorReporter, {\n        error: error,\n        errorInfo: errorInfo,\n        component: this\n      });\n    }\n    if (this.hotComponentUpdate) {\n      this.hotComponentUpdate();\n    } else {\n      throw new Error('React-Hot-Loader: AppContainer should be patched');\n    }\n    return React__default.Children.only(this.props.children);\n  };\n  return AppContainer;\n}(React__default.Component);\nAppContainer.reactHotLoadable = false;\nAppContainer.propTypes = {\n  children: function children(props) {\n    if (React__default.Children.count(props.children) !== 1) {\n      return new Error('Invalid prop \"children\" supplied to AppContainer. ' + 'Expected a single React element with your app’s root component, e.g. <App />.');\n    }\n    return undefined;\n  },\n  errorReporter: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),\n  errorBoundary: PropTypes.bool\n};\nAppContainer.defaultProps = {\n  errorBoundary: true\n};\n\n//  trying first react-lifecycles-compat.polyfill, then trying react-lifecycles-compat, which could be .default\nvar realPolyfill = defaultPolyfill.polyfill || defaultPolyfill__default;\nrealPolyfill(AppContainer);\n\n/* eslint-disable no-underscore-dangle */\n\nvar lazyConstructor = '_ctor';\nvar getLazyConstructor = function getLazyConstructor(target) {\n  // React 16\n  if (target[lazyConstructor]) {\n    return target[lazyConstructor];\n  }\n\n  // React 17\n  if (target._payload) {\n    return target._payload._result;\n  }\n  return null;\n};\nvar setLazyConstructor = function setLazyConstructor(target, replacement) {\n  replacement.isPatchedByReactHotLoader = true;\n\n  // React 16\n  if (target[lazyConstructor]) {\n    target[lazyConstructor] = replacement;\n  }\n  // React 17\n  else if (target._payload) {\n    target._payload._hotUpdated = true;\n    target._payload._result = replacement;\n  } else {\n    console.error('could not update lazy component');\n  }\n};\nvar patched = function patched(fn) {\n  fn.isPatchedByReactHotLoader = true;\n  return fn;\n};\nvar patchLazyConstructor = function patchLazyConstructor(target) {\n  if (configuration.wrapLazy && !getLazyConstructor(target).isPatchedByReactHotLoader) {\n    var ctor = getLazyConstructor(target);\n    setLazyConstructor(target, function () {\n      return ctor().then(function (m) {\n        var C = resolveType(m.default);\n        // chunks has been updated - new hot loader process is taking a place\n        enterHotUpdate();\n        if (!React__default.forwardRef) {\n          return {\n            default: patched(function (props) {\n              return React__default.createElement(AppContainer, null, React__default.createElement(C, props));\n            })\n          };\n        }\n        return {\n          default: patched(\n          // eslint-disable-next-line prefer-arrow-callback\n          React__default.forwardRef(function HotLoaderLazyWrapper(props, ref) {\n            return React__default.createElement(AppContainer, null, React__default.createElement(C, _extends({}, props, {\n              ref: ref\n            })));\n          }))\n        };\n      });\n    });\n  }\n};\nvar updateLazy = function updateLazy(target, type) {\n  var ctor = getLazyConstructor(type);\n  if (getLazyConstructor(target) !== ctor) {\n    // just execute `import` and RHL.register will do the job\n    ctor();\n  }\n  patchLazyConstructor(target);\n  patchLazyConstructor(type);\n};\nvar updateMemo = function updateMemo(target, _ref) {\n  var type = _ref.type;\n  target.type = resolveType(type);\n};\nvar updateForward = function updateForward(target, _ref2) {\n  var render = _ref2.render;\n  target.render = render;\n};\nvar updateContext = function updateContext() {\n  // nil\n};\nvar getInnerComponentType = function getInnerComponentType(component) {\n  var unwrapper = component[UNWRAP_PROXY];\n  return unwrapper ? unwrapper() : component;\n};\nfunction haveEqualSignatures(prevType, nextType) {\n  try {\n    var prevSignature = getSignature(prevType);\n    var nextSignature = getSignature(nextType);\n    if (prevSignature === undefined && nextSignature === undefined) {\n      return true;\n    }\n    if (prevSignature === undefined || nextSignature === undefined) {\n      return false;\n    }\n    if (prevSignature.key !== nextSignature.key) {\n      return false;\n    }\n\n    // TODO: we might need to calculate previous signature earlier in practice,\n    // such as during the first time a component is resolved. We'll revisit this.\n    var prevCustomHooks = prevSignature.getCustomHooks();\n    var nextCustomHooks = nextSignature.getCustomHooks();\n    if (prevCustomHooks.length !== nextCustomHooks.length) {\n      return false;\n    }\n    for (var i = 0; i < nextCustomHooks.length; i++) {\n      if (!haveEqualSignatures(prevCustomHooks[i], nextCustomHooks[i])) {\n        return false;\n      }\n    }\n  } catch (e) {\n    logger.error('React-Hot-Loader: error occurred while comparing hook signature', e);\n    return false;\n  }\n  return true;\n}\nvar areSignaturesCompatible = function areSignaturesCompatible(a, b) {\n  // compare signatures of two components\n  // non-equal component have to remount and there is two options to do it\n  // - fail the comparison, remounting all tree below\n  // - fulfill it, but set `_debugNeedsRemount` on a fiber to drop only local state\n  // the second way is not published yet, so going with the first one\n  if (!haveEqualSignatures(a, b)) {\n    logger.warn('⚛️🔥🎣 Hook order change detected: component', a, 'has been remounted');\n    return false;\n  }\n  return true;\n};\nvar compareRegistered = function compareRegistered(a, b) {\n  return getIdByType(a) === getIdByType(b) && getProxyByType(a) === getProxyByType(b) && areSignaturesCompatible(a, b);\n};\nvar areDeepSwappable = function areDeepSwappable(oldType, newType) {\n  var type = {\n    type: oldType\n  };\n  if (typeof oldType === 'function') {\n    return areSwappable(oldType, newType);\n  }\n  if (isForwardType(type)) {\n    return areDeepSwappable(oldType.render, newType.render);\n  }\n  if (isMemoType(type)) {\n    return areDeepSwappable(oldType.type, newType.type);\n  }\n\n  // that's not safe\n  // if (isLazyType(type)) {\n  //   return areDeepSwappable(oldType._ctor, newType._ctor)\n  // }\n\n  return false;\n};\nvar compareComponents = function compareComponents(oldType, newType, setNewType, baseType) {\n  var defaultResult = oldType === newType;\n  if (oldType && !newType || !oldType && newType || (typeof oldType === 'undefined' ? 'undefined' : _typeof(oldType)) !== (typeof newType === 'undefined' ? 'undefined' : _typeof(newType)) || getElementType(oldType) !== getElementType(newType) || 0) {\n    return defaultResult;\n  }\n  if (getIdByType(newType) || getIdByType(oldType)) {\n    if (!compareRegistered(oldType, newType)) {\n      return false;\n    }\n    defaultResult = true;\n  }\n  if (isForwardType({\n    type: oldType\n  }) && isForwardType({\n    type: newType\n  })) {\n    if (!compareRegistered(oldType.render, newType.render)) {\n      return false;\n    }\n    if (oldType.render === newType.render || areDeepSwappable(oldType, newType)) {\n      setNewType(newType);\n      return true;\n    }\n    return defaultResult;\n  }\n  if (isMemoType({\n    type: oldType\n  }) && isMemoType({\n    type: newType\n  })) {\n    if (!compareRegistered(oldType.type, newType.type)) {\n      return false;\n    }\n    if (oldType.type === newType.type || areDeepSwappable(oldType, newType)) {\n      if (baseType) {\n        // memo form different fibers, why?\n        if (baseType.$$typeof === newType.$$typeof) {\n          setNewType(newType);\n        } else {\n          setNewType(newType.type);\n        }\n      } else {\n        logger.warn('Please update hot-loader/react-dom');\n        if (isReactClass(newType.type)) {\n          setNewType(newType);\n        } else {\n          setNewType(newType.type);\n        }\n      }\n      return true;\n    }\n    return defaultResult;\n  }\n  if (isLazyType({\n    type: oldType\n  })) {\n    updateLazy(oldType, newType);\n    // no need to update\n    // setNewType(newType);\n    return defaultResult;\n  }\n  if (isContextType({\n    type: oldType\n  })) {\n    // update provider\n    setNewType(newType);\n    return defaultResult;\n  }\n  if (typeof newType === 'function' && (defaultResult || newType !== oldType && areSignaturesCompatible(newType, oldType) && areSwappable(newType, oldType))) {\n    var unwrapFactory = newType[UNWRAP_PROXY];\n    var oldProxy = unwrapFactory && getProxyByType(unwrapFactory());\n    if (oldProxy) {\n      oldProxy.dereference();\n      updateProxyById(oldType[PROXY_KEY] || getIdByType(oldType), getInnerComponentType(newType));\n    } else {\n      setNewType(newType);\n    }\n    return true;\n  }\n  return defaultResult;\n};\nvar knownPairs = new WeakMap();\nvar emptyMap$1 = new WeakMap();\nvar getKnownPair = function getKnownPair(oldType, newType) {\n  var pair = knownPairs.get(oldType) || emptyMap$1;\n  return pair.get(newType);\n};\nvar hotComponentCompare = function hotComponentCompare(oldType, preNewType, setNewType, baseType) {\n  var hotActive = hotComparisonOpen();\n  var newType = configuration.integratedResolver ? resolveType(preNewType) : preNewType;\n\n  // TODO: find out the root cause\n  // we could not use \"fast result\" here - go a full part to update a fiber.\n  // const knownType = getKnownPair(oldType, newType);\n  // if (knownType !== undefined) {\n  //   return knownType;\n  // }\n\n  var result = oldType === newType;\n  if (hotActive) {\n    // pre fail components which could not be merged\n    if (!isReloadableComponent(oldType) || !isReloadableComponent(newType) || isColdType(oldType) || isColdType(oldType) || !oldType || !newType || 0) {\n      return result;\n    }\n    result = compareComponents(oldType, newType, setNewType, baseType);\n    var pair = knownPairs.get(oldType) || new WeakMap();\n    pair.set(newType, result);\n    knownPairs.set(oldType, pair);\n    return result;\n  }\n\n  // result - true if components are equal, or were \"equal\" at any point in the past\n  return result || getKnownPair(oldType, newType) || false;\n};\n\n/* eslint-disable no-use-before-define */\n\nvar forceSimpleSFC = {\n  proxy: {\n    pureSFC: true\n  }\n};\nvar hookWrapper = function hookWrapper(hook) {\n  var wrappedHook = function wrappedHook(cb, deps) {\n    if (configuration.reloadHooks && deps) {\n      var inputs = [].concat(deps);\n\n      // reload hooks which have changed string representation\n      if (configuration.reloadHooksOnBodyChange) {\n        inputs.push(String(cb));\n      }\n      if (\n      // reload hooks with dependencies\n      deps.length > 0 ||\n      // reload all hooks of option is set\n      configuration.reloadLifeCycleHooks && deps.length === 0) {\n        inputs.push(getHotGeneration());\n      }\n      return hook(cb, inputs);\n    }\n    return hook(cb, deps);\n  };\n  wrappedHook.isPatchedByReactHotLoader = true;\n  return wrappedHook;\n};\nvar noDeps = function noDeps() {\n  return [];\n};\nvar reactHotLoader = {\n  signature: function signature(type, key) {\n    var getCustomHooks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noDeps;\n    addSignature(type, {\n      key: key,\n      getCustomHooks: getCustomHooks\n    });\n    return type;\n  },\n  register: function register(type, uniqueLocalName, fileName) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var id = fileName + '#' + uniqueLocalName;\n    if (isCompositeComponent(type) && typeof uniqueLocalName === 'string' && uniqueLocalName && typeof fileName === 'string' && fileName) {\n      var proxy = getProxyById(id);\n      if (proxy && proxy.getCurrent() !== type) {\n        if (!configuration.IS_REACT_MERGE_ENABLED) {\n          if (isTypeBlacklisted(type) || isTypeBlacklisted(proxy.getCurrent())) {\n            logger.error('React-hot-loader: Cold component', uniqueLocalName, 'at', fileName, 'has been updated');\n          }\n        }\n      }\n      if (configuration.onComponentRegister) {\n        configuration.onComponentRegister(type, uniqueLocalName, fileName);\n      }\n      if (configuration.onComponentCreate) {\n        configuration.onComponentCreate(type, getComponentDisplayName(type));\n      }\n      registerComponent(updateProxyById(id, type, options).get(), 2);\n      registerComponent(type);\n      increment();\n    }\n    if (isContextType({\n      type: type\n    })) {\n      // possible options - Context, Consumer, Provider.\n      ['Provider', 'Consumer'].forEach(function (prop) {\n        var descriptor = Object.getOwnPropertyDescriptor(type, prop);\n        if (descriptor && descriptor.value) {\n          updateFunctionProxyById(id + ':' + prop, descriptor.value, updateContext);\n        }\n      });\n      updateFunctionProxyById(id, type, updateContext);\n      increment();\n    }\n    if (isLazyType({\n      type: type\n    })) {\n      updateFunctionProxyById(id, type, updateLazy);\n      increment();\n    }\n    if (isForwardType({\n      type: type\n    })) {\n      reactHotLoader.register(type.render, uniqueLocalName + ':render', fileName, forceSimpleSFC);\n      updateFunctionProxyById(id, type, updateForward);\n      increment();\n    }\n    if (isMemoType({\n      type: type\n    })) {\n      reactHotLoader.register(type.type, uniqueLocalName + ':memo', fileName, forceSimpleSFC);\n      updateFunctionProxyById(id, type, updateMemo);\n      increment();\n    }\n  },\n  reset: function reset() {\n    resetProxies();\n  },\n  preact: function preact(instance) {\n    preactAdapter(instance, resolveType);\n  },\n  resolveType: function resolveType$$1(type) {\n    return resolveType(type);\n  },\n  patch: function patch(React$$1, ReactDOM$$1) {\n    var typeResolver = resolveType;\n    /* eslint-disable no-console */\n    if (ReactDOM$$1 && !ReactDOM$$1.render) {\n      logger.error('React-Hot-Loader: broken state detected, please import React-Hot-Loader before react-dom, see https://github.com/gaearon/react-hot-loader/issues/1315');\n    }\n    if (ReactDOM$$1 && ReactDOM$$1.setHotElementComparator) {\n      ReactDOM$$1.setHotElementComparator(hotComponentCompare);\n      configuration.disableHotRenderer = configuration.disableHotRendererWhenInjected;\n      configuration.ignoreSFC = configuration.ignoreSFCWhenInjected;\n      configuration.IS_REACT_MERGE_ENABLED = true;\n      configuration.showReactDomPatchNotification = false;\n      configuration.integratedComparator = true;\n      if (ReactDOM$$1.setHotTypeResolver) {\n        configuration.integratedResolver = true;\n        typeResolver = resolveSimpleType;\n        ReactDOM$$1.setHotTypeResolver(resolveType);\n      }\n    }\n\n    // PATCH REACT METHODS\n\n    /* eslint-enable */\n    if (!React$$1.createElement.isPatchedByReactHotLoader) {\n      var originalCreateElement = React$$1.createElement;\n      // Trick React into rendering a proxy so that\n      // its state is preserved when the class changes.\n      // This will update the proxy if it's for a known type.\n      React$$1.createElement = function (type) {\n        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        return originalCreateElement.apply(undefined, [typeResolver(type)].concat(args));\n      };\n      React$$1.createElement.isPatchedByReactHotLoader = true;\n    }\n    if (!React$$1.cloneElement.isPatchedByReactHotLoader) {\n      var originalCloneElement = React$$1.cloneElement;\n      React$$1.cloneElement = function (element) {\n        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n        var newType = element.type && typeResolver(element.type);\n        if (newType && newType !== element.type) {\n          return originalCloneElement.apply(undefined, [_extends({}, element, {\n            type: newType\n          })].concat(args));\n        }\n        return originalCloneElement.apply(undefined, [element].concat(args));\n      };\n      React$$1.cloneElement.isPatchedByReactHotLoader = true;\n    }\n    if (!React$$1.createFactory.isPatchedByReactHotLoader) {\n      // Patch React.createFactory to use patched createElement\n      // because the original implementation uses the internal,\n      // unpatched ReactElement.createElement\n      React$$1.createFactory = function (type) {\n        var factory = React$$1.createElement.bind(null, type);\n        factory.type = type;\n        return factory;\n      };\n      React$$1.createFactory.isPatchedByReactHotLoader = true;\n    }\n    if (!React$$1.Children.only.isPatchedByReactHotLoader) {\n      var originalChildrenOnly = React$$1.Children.only;\n      // Use the same trick as React.createElement\n      React$$1.Children.only = function (children) {\n        return originalChildrenOnly(_extends({}, children, {\n          type: typeResolver(children.type)\n        }));\n      };\n      React$$1.Children.only.isPatchedByReactHotLoader = true;\n    }\n\n    // PATCH REACT HOOKS\n\n    if (React$$1.useEffect && !React$$1.useEffect.isPatchedByReactHotLoader) {\n      React$$1.useEffect = hookWrapper(React$$1.useEffect);\n      React$$1.useLayoutEffect = hookWrapper(React$$1.useLayoutEffect);\n      React$$1.useCallback = hookWrapper(React$$1.useCallback);\n      React$$1.useMemo = hookWrapper(React$$1.useMemo);\n\n      // transform context for useContext\n      var useContext = React$$1.useContext;\n      React$$1.useContext = function (context) {\n        for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n          args[_key3 - 1] = arguments[_key3];\n        }\n        return useContext.apply(undefined, [typeResolver(context)].concat(args));\n      };\n    }\n\n    // reactHotLoader.reset()\n  }\n};\nvar openedModules = {};\nvar lastModuleOpened = '';\nvar getLastModuleOpened = function getLastModuleOpened() {\n  return lastModuleOpened;\n};\nvar hotModules = {};\nvar createHotModule = function createHotModule() {\n  return {\n    instances: [],\n    updateTimeout: 0\n  };\n};\nvar hotModule = function hotModule(moduleId) {\n  if (!hotModules[moduleId]) {\n    hotModules[moduleId] = createHotModule();\n  }\n  return hotModules[moduleId];\n};\nvar isOpened = function isOpened(sourceModule) {\n  return sourceModule && !!openedModules[sourceModule.id];\n};\nvar enter = function enter(sourceModule) {\n  if (sourceModule && sourceModule.id) {\n    lastModuleOpened = sourceModule.id;\n    openedModules[sourceModule.id] = true;\n  } else {\n    logger.warn('React-hot-loader: no `module` variable found. Did you shadow a system variable?');\n  }\n};\nvar leave = function leave(sourceModule) {\n  if (sourceModule && sourceModule.id) {\n    delete openedModules[sourceModule.id];\n  }\n};\nvar createQueue = function createQueue() {\n  var runner = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (a) {\n    return a();\n  };\n  var promise = void 0;\n  var queue = [];\n  var runAll = function runAll() {\n    var oldQueue = queue;\n    oldQueue.forEach(function (cb) {\n      return cb();\n    });\n    queue = [];\n  };\n  var add = function add(cb) {\n    if (queue.length === 0) {\n      promise = Promise.resolve().then(function () {\n        return runner(runAll);\n      });\n    }\n    queue.push(cb);\n    return promise;\n  };\n  return add;\n};\n\n/* eslint-disable camelcase, no-undef */\nvar requireIndirect = typeof __webpack_require__ !== 'undefined' ? __webpack_require__ : require;\n/* eslint-enable */\n\nvar chargeFailbackTimer = function chargeFailbackTimer(id) {\n  return setTimeout(function () {\n    var error = 'hot update failed for module \"' + id + '\". Last file processed: \"' + getLastModuleOpened() + '\".';\n    logger.error(error);\n    logException({\n      toString: function toString() {\n        return error;\n      }\n    });\n    // 100 ms more \"code\" tolerant that 0, and would catch error in any case\n  }, 100);\n};\nvar clearFailbackTimer = function clearFailbackTimer(timerId) {\n  return clearTimeout(timerId);\n};\nvar createHoc = function createHoc(SourceComponent, TargetComponent) {\n  hoistNonReactStatic(TargetComponent, SourceComponent);\n  TargetComponent.displayName = 'HotExported' + getComponentDisplayName(SourceComponent);\n  return TargetComponent;\n};\nvar runInRequireQueue = createQueue();\nvar runInRenderQueue = createQueue(function (cb) {\n  if (ReactDOM.unstable_batchedUpdates) {\n    ReactDOM.unstable_batchedUpdates(cb);\n  } else {\n    cb();\n  }\n});\nvar makeHotExport = function makeHotExport(sourceModule, moduleId) {\n  var updateInstances = function updateInstances(possibleError) {\n    if (possibleError && possibleError instanceof Error) {\n      console.error(possibleError);\n      return;\n    }\n    var module = hotModule(moduleId);\n    var deepUpdate = function deepUpdate() {\n      // force flush all updates\n      runInRenderQueue(function () {\n        enterHotUpdate();\n        var gen = getHotGeneration();\n        module.instances.forEach(function (inst) {\n          return inst.forceUpdate();\n        });\n        if (configuration.trackTailUpdates) {\n          var runLimit = 0;\n          var checkTailUpdates = function checkTailUpdates() {\n            setTimeout(function () {\n              if (getHotGeneration() !== gen) {\n                // we know that some components were updated, but not tracking which ones\n                // even if their updates might be incorporated automatically (like lazy)\n                // we dont know which one should be tracked, and which updates are important\n                logger.warn('React-Hot-Loader: some components were updated out-of-bound. Updating your app to reconcile the changes.');\n                // increment generator for cache-busting existing tree\n                increment();\n                deepUpdate();\n              } else if (++runLimit < 5) {\n                checkTailUpdates();\n              }\n            }, 16);\n          };\n          checkTailUpdates();\n        }\n      });\n    };\n\n    // require all modules\n    runInRequireQueue(function () {\n      try {\n        // webpack will require everything by this time\n        // but let's double check...\n        requireIndirect(moduleId);\n      } catch (e) {\n        console.error('React-Hot-Loader: error detected while loading', moduleId);\n        console.error(e);\n      }\n    }).then(deepUpdate);\n  };\n  if (sourceModule.hot) {\n    // Mark as self-accepted for Webpack (callback is an Error Handler)\n    // Update instances for Parcel (callback is an Accept Handler)\n    sourceModule.hot.accept(updateInstances);\n\n    // Webpack way\n    if (sourceModule.hot.addStatusHandler) {\n      if (sourceModule.hot.status() === 'idle') {\n        sourceModule.hot.addStatusHandler(function (status) {\n          if (status === 'apply') {\n            clearExceptions();\n            updateInstances();\n          }\n        });\n      }\n    }\n  } else {\n    logger.warn('React-hot-loader: Hot Module Replacement is not enabled');\n  }\n};\nvar hot = function hot(sourceModule) {\n  if (!sourceModule) {\n    // this is fatal\n    throw new Error('React-hot-loader: `hot` was called without any argument provided');\n  }\n  var moduleId = sourceModule.id || sourceModule.i || sourceModule.filename;\n  if (!moduleId) {\n    console.error('`module` provided', sourceModule);\n    throw new Error('React-hot-loader: `hot` could not find the `name` of the the `module` you have provided');\n  }\n  var module = hotModule(moduleId);\n  makeHotExport(sourceModule, moduleId);\n  clearExceptions();\n  var failbackTimer = chargeFailbackTimer(moduleId);\n  var firstHotRegistered = false;\n\n  // TODO: Ensure that all exports from this file are react components.\n\n  return function (WrappedComponent, props) {\n    clearFailbackTimer(failbackTimer);\n    // register proxy for wrapped component\n    // only one hot per file would use this registration\n    if (!firstHotRegistered) {\n      firstHotRegistered = true;\n      reactHotLoader.register(WrappedComponent, getComponentDisplayName(WrappedComponent), 'RHL' + moduleId);\n    }\n    return createHoc(WrappedComponent, function (_Component) {\n      inherits(ExportedComponent, _Component);\n      function ExportedComponent() {\n        classCallCheck(this, ExportedComponent);\n        return possibleConstructorReturn(this, _Component.apply(this, arguments));\n      }\n      ExportedComponent.prototype.componentDidMount = function componentDidMount() {\n        module.instances.push(this);\n      };\n      ExportedComponent.prototype.componentWillUnmount = function componentWillUnmount() {\n        var _this2 = this;\n        if (isOpened(sourceModule)) {\n          var componentName = getComponentDisplayName(WrappedComponent);\n          logger.error('React-hot-loader: Detected AppContainer unmount on module \\'' + moduleId + '\\' update.\\n' + ('Did you use \"hot(' + componentName + ')\" and \"ReactDOM.render()\" in the same file?\\n') + ('\"hot(' + componentName + ')\" shall only be used as export.\\n') + 'Please refer to \"Getting Started\" (https://github.com/gaearon/react-hot-loader/).');\n        }\n        module.instances = module.instances.filter(function (a) {\n          return a !== _this2;\n        });\n      };\n      ExportedComponent.prototype.render = function render() {\n        return React__default.createElement(AppContainer, props, React__default.createElement(WrappedComponent, this.props));\n      };\n      return ExportedComponent;\n    }(React.Component));\n  };\n};\nreactHotLoader.register(AppContainer, 'AppContainer', 'hot-dev');\nvar getProxyOrType = function getProxyOrType(type) {\n  var proxy = getProxyByType(type);\n  return proxy ? proxy.get() : type;\n};\nvar areComponentsEqual = function areComponentsEqual(a, b) {\n  return getProxyOrType(a) === getProxyOrType(b);\n};\nvar compareOrSwap = function compareOrSwap(oldType, newType) {\n  return hotComponentCompare(oldType, newType);\n};\nvar cold = function cold(type) {\n  blacklistByType(type);\n  return type;\n};\nvar configureComponent = function configureComponent(component, options) {\n  return setComponentOptions(component, options);\n};\nvar setConfig = function setConfig(config) {\n  return setConfiguration(config);\n};\nreactHotLoader.patch(React__default, ReactDOM);\nexports.default = reactHotLoader;\nexports.AppContainer = AppContainer;\nexports.hot = hot;\nexports.enterModule = enter;\nexports.leaveModule = leave;\nexports.areComponentsEqual = areComponentsEqual;\nexports.compareOrSwap = compareOrSwap;\nexports.cold = cold;\nexports.configureComponent = configureComponent;\nexports.setConfig = setConfig;","map":null,"metadata":{},"sourceType":"script"}